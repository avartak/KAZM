// src/Scanner.cc generated by reflex 2.1.5 from src/lexer.l

#define REFLEX_VERSION "2.1.5"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_header_file         "include/Scanner.h"
#define REFLEX_OPTION_lex                 scan
#define REFLEX_OPTION_lexer               Scanner
#define REFLEX_OPTION_namespace           kazm
#define REFLEX_OPTION_noline              true
#define REFLEX_OPTION_outfile             "src/Scanner.cc"
#define REFLEX_OPTION_token_type          kazm::Token

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#include <Token.h>


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace kazm {

class Scanner : public reflex::AbstractLexer<reflex::Matcher> {
 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  Scanner(
      const reflex::Input& input = reflex::Input(),
      std::ostream&        os    = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  virtual kazm::Token scan(void);
  kazm::Token scan(const reflex::Input& input)
  {
    in(input);
    return scan();
  }
  kazm::Token scan(const reflex::Input& input, std::ostream *os)
  {
    in(input);
    if (os)
      out(*os);
    return scan();
  }
};

} // namespace kazm

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////



#include <iostream>

#define RETURN(x)    return Token(x, str(), lineno())



////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

kazm::Token kazm::Scanner::scan(void)
{
  static const char *REGEX_INITIAL = "(?m)((?:[\\x09-\\x0d\\x20])+)|((?:\\Q//\\E).*)|((?:\\QOPENQASM\\E)(?:[\\x09\\x20])+(?:(?:(?:\\Q0\\E)|[1-9]+(?:[0-9])*))(?:\\Q.\\E)(?:(?:(?:\\Q0\\E)|[1-9]+(?:[0-9])*))(?:[\\x09\\x20])*(?:\\Q;\\E))|((?:\\Q{\\E))|((?:\\Q}\\E))|((?:\\Q[\\E))|((?:\\Q]\\E))|((?:\\Q(\\E))|((?:\\Q)\\E))|((?:\\Q,\\E))|((?:\\Q;\\E))|((?:\\Q+\\E))|((?:\\Q-\\E))|((?:\\Q*\\E))|((?:\\Q/\\E))|((?:\\Q^\\E))|((?:\\Q->\\E))|((?:\\Q==\\E))|((?:\\Qif\\E))|((?:\\Qpi\\E))|((?:\\Qsin\\E))|((?:\\Qcos\\E))|((?:\\Qtan\\E))|((?:\\Qexp\\E))|((?:\\Qln\\E))|((?:\\Qsqrt\\E))|((?:\\Qqreg\\E))|((?:\\Qcreg\\E))|((?:\\Qgate\\E))|((?:\\Qopaque\\E))|((?:\\Qbarrier\\E))|((?:\\Qmeasure\\E))|((?:\\Qreset\\E))|((?:\\QU\\E))|((?:\\QCX\\E))|((?:\\Qinclude\\E))|((?:(?:(?:\\Q0\\E)|[1-9]+(?:[0-9])*)))|((?:[0-9])+(?:\\Q.\\E)(?:[0-9])*(?:(?:[Ee][\\x2b\\x2d]?(?:[0-9])+))?)|((?:[0-9])*(?:\\Q.\\E)(?:[0-9])+(?:(?:[Ee][\\x2b\\x2d]?(?:[0-9])+))?)|([a-z][0-9A-Z_a-z]*)|(\"[^\"]+\")|(.)";
  static const reflex::Pattern PATTERN_INITIAL(REGEX_INITIAL);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
{ RETURN(0); }

            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule src/lexer.l:21: {W}+ :
            break;
          case 2: // rule src/lexer.l:22: "//".* :


            break;
          case 3: // rule src/lexer.l:24: "OPENQASM"{S}+{I}"."{I}{S}*";" :
{ RETURN(T_HEADER); }

            break;
          case 4: // rule src/lexer.l:26: "{" :
{ RETURN('{'); }
            break;
          case 5: // rule src/lexer.l:27: "}" :
{ RETURN('}'); }
            break;
          case 6: // rule src/lexer.l:28: "[" :
{ RETURN('['); }
            break;
          case 7: // rule src/lexer.l:29: "]" :
{ RETURN(']'); }
            break;
          case 8: // rule src/lexer.l:30: "(" :
{ RETURN('('); }
            break;
          case 9: // rule src/lexer.l:31: ")" :
{ RETURN(')'); }
            break;
          case 10: // rule src/lexer.l:32: "," :
{ RETURN(','); }
            break;
          case 11: // rule src/lexer.l:33: ";" :
{ RETURN(';'); }
            break;
          case 12: // rule src/lexer.l:34: "+" :
{ RETURN('+'); }
            break;
          case 13: // rule src/lexer.l:35: "-" :
{ RETURN('-'); }
            break;
          case 14: // rule src/lexer.l:36: "*" :
{ RETURN('*'); }
            break;
          case 15: // rule src/lexer.l:37: "/" :
{ RETURN('/'); }
            break;
          case 16: // rule src/lexer.l:38: "^" :
{ RETURN('^'); }
            break;
          case 17: // rule src/lexer.l:39: "->" :
{ RETURN(T_YIELDS); }
            break;
          case 18: // rule src/lexer.l:40: "==" :
{ RETURN(T_EQUALS); }
            break;
          case 19: // rule src/lexer.l:41: "if" :
{ RETURN(T_IF); }
            break;
          case 20: // rule src/lexer.l:42: "pi" :
{ RETURN(T_PI); }
            break;
          case 21: // rule src/lexer.l:43: "sin" :
{ RETURN(T_SIN); }
            break;
          case 22: // rule src/lexer.l:44: "cos" :
{ RETURN(T_COS); }
            break;
          case 23: // rule src/lexer.l:45: "tan" :
{ RETURN(T_TAN); }
            break;
          case 24: // rule src/lexer.l:46: "exp" :
{ RETURN(T_EXP); }
            break;
          case 25: // rule src/lexer.l:47: "ln" :
{ RETURN(T_LN); }
            break;
          case 26: // rule src/lexer.l:48: "sqrt" :
{ RETURN(T_SQRT); }
            break;
          case 27: // rule src/lexer.l:49: "qreg" :
{ RETURN(T_QREG); }
            break;
          case 28: // rule src/lexer.l:50: "creg" :
{ RETURN(T_CREG); }
            break;
          case 29: // rule src/lexer.l:51: "gate" :
{ RETURN(T_GATE); }
            break;
          case 30: // rule src/lexer.l:52: "opaque" :
{ RETURN(T_OPAQUE); }
            break;
          case 31: // rule src/lexer.l:53: "barrier" :
{ RETURN(T_BARRIER); }
            break;
          case 32: // rule src/lexer.l:54: "measure" :
{ RETURN(T_MEASURE); }
            break;
          case 33: // rule src/lexer.l:55: "reset" :
{ RETURN(T_RESET); }
            break;
          case 34: // rule src/lexer.l:56: "U" :
{ RETURN(T_U); }
            break;
          case 35: // rule src/lexer.l:57: "CX" :
{ RETURN(T_CX); }
            break;
          case 36: // rule src/lexer.l:58: "include" :
{ RETURN(T_INCLUDE); }

            break;
          case 37: // rule src/lexer.l:60: {I} :
{ RETURN(T_NNINTEGER); }
            break;
          case 38: // rule src/lexer.l:61: {D}+"."{D}*{E}? :
{ RETURN(T_REAL); }
            break;
          case 39: // rule src/lexer.l:62: {D}*"."{D}+{E}? :
{ RETURN(T_REAL); }
            break;
          case 40: // rule src/lexer.l:63: [a-z][a-zA-Z_0-9]* :
{ RETURN(T_ID); }
            break;
          case 41: // rule src/lexer.l:64: \"[^\"]+\" :
{ RETURN(T_FILENAME); }

            break;
          case 42: // rule src/lexer.l:66: . :
{ RETURN(T_UNDEF); }
            break;
        }
  }
}
